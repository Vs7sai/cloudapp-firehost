{
  "success": true,
  "data": {
    "topic": "kubernetes",
    "difficulty": "beginner",
    "questions": [
      {
        "id": 1,
        "text": "What is Kubernetes?",
        "explanation": "Imagine you have many small digital boxes (containers) that contain your applications. Managing these boxes – making sure they are always running, updated, and have enough resources – can be very complicated. \n\n**Kubernetes (often called K8s)** is like a very smart **orchestra conductor** or a **robot manager** for these digital boxes. Its main job is to **automatically handle** where your application boxes run, make sure they stay healthy, and quickly give them more resources if many people start using your app. It ties everything together so your applications run smoothly and reliably, without you having to manually move or start each box."
      },
      {
        "id": 2,
        "text": "Why was Kubernetes created?",
        "explanation": "Before Kubernetes, when companies used containers, they had a big problem: how do you manage hundreds or thousands of them across many different computers? It was like trying to manage a huge fleet of individual cars by hand – impossible!\n\n**Kubernetes was created to solve this 'container sprawl' problem.** It automates the messy parts of running applications in containers at a large scale. Think of it as building a smart city for your apps, where the infrastructure takes care of itself, so developers can focus on building new features rather than worrying about servers crashing or apps slowing down."
      },
      {
        "id": 3,
        "text": "What is a Kubernetes Cluster?",
        "explanation": "A Kubernetes **cluster** is simply a **group of interconnected computers** (called 'nodes') that work together as a single, powerful machine to run your applications. Instead of running apps on one computer, you spread them across many.\n\nThis group has two main types of computers:\n\n* **Control Plane (the 'brain'):** This computer (or set of computers) makes all the decisions about where your apps run and how they behave.\n* **Worker Nodes (the 'workers'):** These are the computers where your actual applications (in their containers) live and run."
      },
      {
        "id": 4,
        "text": "What is a Node in Kubernetes?",
        "explanation": "In a Kubernetes cluster, a **Node** is just **one single computer** that forms part of the group. It can be a real physical machine or a virtual one in the cloud.\n\nIts job is to:\n\n* **Provide computing power:** It has CPU, memory, and storage for your apps.\n* **Run your applications:** It hosts the small digital boxes (Pods) that contain your applications.\n* **Communicate with the brain:** It constantly talks to the 'Control Plane' to get instructions and report its status."
      },
      {
        "id": 5,
        "text": "What is the Control Plane (Master Node) in Kubernetes?",
        "explanation": "The **Control Plane** (sometimes called the 'master node' in older terms) is the **decision-making center** of your Kubernetes cluster. It's like the main office or the general of an army.\n\nIts main responsibilities are to:\n\n* **Orchestrate everything:** Decides where to place your applications (Pods) on the worker nodes.\n* **Monitor health:** Keeps an eye on all worker nodes and applications to ensure they are healthy.\n* **Maintain desired state:** If you say you want 3 copies of your app running, the Control Plane makes sure exactly 3 are always active, even if one crashes.\n\nIt doesn't run your application containers directly, but it directs the worker nodes on what to do.",
      },
      {
        "id": 6,
        "text": "Name the key components of the Kubernetes Control Plane.",
        "explanation": "The Control Plane has several specialized 'offices' or parts that work together:\n\n* **Kube-apiserver:** This is like the **main switchboard or receptionist**. Everyone (humans and other parts of Kubernetes) talks to this part to give instructions or ask for information about the cluster.\n* **etcd:** This is the **cluster's memory or database**. It stores *everything* about the cluster's current situation and your desired settings – like what apps should run, where they are, and how many copies you want.\n* **Kube-scheduler:** This is the **task allocator**. It looks for any new applications that need to run and intelligently decides *which* worker node is the best fit for them, considering their needs (like CPU or memory).\n* **Kube-controller-manager:** This is like a **group of persistent employees**. Each 'controller' within it has a specific job to ensure that the cluster's *actual* state matches your *desired* state (e.g., if you want 3 app copies, a controller ensures 3 are running).\n* **Cloud-controller-manager (optional):** If you're running Kubernetes in a cloud (like AWS, Google Cloud, Azure), this part helps Kubernetes talk to that specific cloud provider to manage things like network load balancers or storage.",
      },
      {
        "id": 7,
        "text": "Name the key components of a Worker Node in Kubernetes.",
        "explanation": "Each Worker Node has its own set of tools to perform its duties:\n\n* **Kubelet:** This is the **node's diligent agent**. It's the primary communicator with the Control Plane. It receives instructions (like 'run this application Pod') and ensures that the containers specified in those instructions are actually running and healthy on its node.\n* **Kube-proxy:** This is the **node's network traffic cop**. It manages the network rules on the node, making sure that when people try to reach your application, their requests are correctly sent to the right container (Pod) on that node. It also helps with basic load balancing.\n* **Container Runtime:** This is the **container engine itself** (like Docker, containerd, or CRI-O). It's the software responsible for actually starting, stopping, and managing the individual containers that make up your application Pods.",
      },
      {
        "id": 8,
        "text": "What is a Pod in Kubernetes?",
        "explanation": "Think of a **Pod** as the **smallest building block** in Kubernetes, like a tiny, self-contained apartment building.\n\nHere's what makes it special:\n\n* **It runs your application:** A Pod always contains at least one of your application containers.\n* **It can have helpers:** Sometimes, a Pod might have a main application container plus one or more smaller 'helper' containers (called sidecars) that do things like logging or monitoring for the main app.\n* **Shared resources:** All containers *inside the same Pod* share the same network address (IP address) and can easily share storage, making it perfect for tightly related parts of your application.",
      },
      {
        "id": 9,
        "text": "Why do Pods exist instead of just running containers directly?",
        "explanation": "This is a great question! It might seem simpler to just run individual containers, but Pods offer important advantages:\n\n* **Grouped containers:** For applications with multiple, closely related parts (like a main app and a logging agent), Pods allow them to be grouped and managed as a single unit. They share resources naturally.\n* **Simplified networking:** All containers in a Pod share the same network identity, making it easy for them to talk to each other directly using `localhost`.\n* **Proper lifecycle:** Kubernetes manages Pods, not just individual containers. If a container crashes, Kubernetes can restart *only* that container within the Pod without affecting others. If the whole Pod needs to move to another node, Kubernetes handles the entire unit.\n\nSo, Pods are designed for the **application's runtime environment**, not just the container itself, making large-scale management much easier."
      },
      {
        "id": 10,
        "text": "What is a Deployment in Kubernetes?",
        "explanation": "A **Deployment** is your blueprint for **how to run and update your application** in Kubernetes. It's like telling Kubernetes, 'I want this version of my app, with this many copies, and if I update it, here's how to do it safely.'\n\nIt helps you:\n\n* **Ensure copies are running:** If you say you want 3 copies (replicas) of your app, the Deployment constantly works to make sure 3 Pods are always active. If one crashes, it replaces it automatically.\n* **Update safely:** It manages rolling updates, meaning it replaces old versions of your app with new ones gradually, without downtime.\n* **Rollback easily:** If a new version has problems, it allows you to quickly revert to a previous, stable version.",
      },
      {
        "id": 11,
        "text": "What is a Service in Kubernetes?",
        "explanation": "Imagine you have many copies of your web application (Pods) running, but their addresses (IPs) keep changing as they are created or restarted. How do other parts of your application or users find them?\n\nThat's where a **Service** comes in. A Service is like a **permanent, unchanging postal address** for a group of Pods. It provides:\n\n* **Stable access:** A single, consistent IP address and DNS name that never changes, even if the Pods behind it do.\n* **Load balancing:** It automatically distributes incoming traffic across all healthy Pods that belong to it.\n* **Decoupling:** It separates how your app is accessed from how it actually runs, making your system more flexible.",
      },
      {
        "id": 12,
        "text": "What is kubectl get?",
        "explanation": "### Purpose: Display existing Kubernetes resources.\n\n**Explanation:** This is your primary 'read' command. Think of it as asking Kubernetes, 'Show me what's running!' You can view different types of objects like Pods, Deployments, Services, Nodes, and more. It helps you quickly see the current state of your cluster's components.\n\n**Basic Example: List all Pods in the current Namespace.**\n```bash\nkubectl get pods\n```\n\n**Advanced Example: List all Deployments in the 'production' Namespace, showing more details (like internal IP, node name) and outputting in YAML format for full configuration.**\n```bash\nkubectl get deployments -n production -o yaml\n```"
      },
      {
        "id": 13,
        "text": "What is kubectl describe?",
        "explanation": "### Purpose: Show detailed information about a specific resource.\n\n**Explanation:** When `kubectl get` gives you a summary, `kubectl describe` gives you the full story. It's like asking for a comprehensive report or dossier on a specific object. It's invaluable for debugging because it shows recent events, current status, configurations, and related objects, helping you understand *why* something is or isn't working.\n\n**Basic Example: Get detailed information about a Pod named 'my-web-app-pod'.**\n```bash\nkubectl describe pod my-web-app-pod\n```\n\n**Advanced Example: Get details for a Service named 'my-database-service' in the 'dev' Namespace.**\n```bash\nkubectl describe service my-database-service -n dev\n```"
      },
      {
        "id": 14,
        "text": "What is kubectl apply?",
        "explanation": "### Purpose: Create or update resources from a file (YAML/JSON).\n\n**Explanation:** This is how you tell Kubernetes your desired state for your applications and infrastructure. You define your Pods, Deployments, Services, ConfigMaps, etc., in configuration files (usually YAML). `kubectl apply` reads these files and pushes those definitions to the cluster. Kubernetes then works to make the cluster's *actual* state match your *desired* state defined in the file.\n\n**Basic Example: Apply a configuration defined in 'my-app-deployment.yaml' to create or update a Deployment.**\n```bash\nkubectl apply -f my-app-deployment.yaml\n```\n\n**Advanced Example: Apply all configuration files found within a directory named 'k8s-configs'. This is common for deploying entire applications.**\n```bash\nkubectl apply -f ./k8s-configs/\n```"
      },
      {
        "id": 15,
        "text": "What is kubectl delete?",
        "explanation": "### Purpose: Delete resources by file, name, type, or labels.\n\n**Explanation:** This command removes resources from your Kubernetes cluster. You can specify what to delete in several ways: by pointing to the same configuration file you used with `apply`, by naming the specific object, or by deleting all objects of a certain type that have specific labels.\n\n**Basic Example: Delete a Deployment named 'my-web-app'.**\n```bash\nkubectl delete deployment my-web-app\n```\n\n**Advanced Example: Delete all Pods that have the label `app: my-old-service` in the 'legacy' Namespace.**\n```bash\nkubectl delete pods -l app=my-old-service -n legacy\n```"
      },
      {
        "id": 16,
        "text": "What is kubectl exec?",
        "explanation": "### Purpose: Execute a command inside a running container within a Pod.\n\n**Explanation:** This command lets you run commands directly inside a container that's already running within a Pod. It's incredibly useful for debugging, inspecting the container's environment, checking file systems, or interacting with the application directly, without needing to expose ports or modify the application.\n\n**Basic Example: Open an interactive shell (like Bash) inside a container of a Pod named 'my-app-pod'. The `--` separates `kubectl exec` arguments from the command to be run inside the container.**\n```bash\nkubectl exec -it my-app-pod -- bash\n```\n\n**Advanced Example: Run a specific command (e.g., `ls -l /app`) inside a specific container named 'sidecar-logger' within a Pod that has multiple containers.**\n```bash\nkubectl exec my-multi-container-pod -c sidecar-logger -- ls -l /app\n```"
      },
      {
        "id": 17,
        "text": "What is kubectl logs?",
        "explanation": "### Purpose: Print logs from a container in a Pod.\n\n**Explanation:** This command allows you to view the output (logs) from your application's containers. Logs are essential for understanding what your application is doing, diagnosing errors, and monitoring its behavior. You can view past logs or stream new logs as they are generated.\n\n**Basic Example: Show the logs for a Pod named 'my-processor-pod'.**\n```bash\nkubectl logs my-processor-pod\n```\n\n**Advanced Example: Follow (stream) the logs for a container named 'worker-c' within 'my-job-pod', showing only logs from the last 5 minutes.**\n```bash\nkubectl logs -f my-job-pod -c worker-c --since 5m\n```"
      },
      {
        "id": 18,
        "text": "What is kubectl rollout?",
        "explanation": "### Purpose: Manage the rollout of a Deployment or DaemonSet.\n\n**Explanation:** This command is specifically for managing how new versions of your application are deployed and updated, especially with Deployments. It allows you to check the status of an update, pause it, resume it, or even revert to a previous working version if something goes wrong, ensuring a smooth and safe release process.\n\n**Basic Example: Check the status of the latest rollout for a Deployment named 'my-api-deployment'.**\n```bash\nkubectl rollout status deployment/my-api-deployment\n```\n\n**Advanced Example: Undo the last rollout for a Deployment, effectively reverting to the previous version of the application.**\n```bash\nkubectl rollout undo deployment/my-api-deployment\n```"
      },
      {
        "id": 19,
        "text": "What is kubectl scale?",
        "explanation": "### Purpose: Manually scale a Deployment, ReplicaSet, StatefulSet, or ReplicationController.\n\n**Explanation:** This command lets you manually adjust the number of running copies (replicas) of your application. If your application needs to handle more users, you can increase the replica count. If traffic is low, you can reduce it to save resources. Kubernetes will then automatically create or delete Pods to match your desired number.\n\n**Basic Example: Scale the 'my-web-app' Deployment to have 5 running Pods.**\n```bash\nkubectl scale deployment my-web-app --replicas=5\n```\n\n**Advanced Example: Scale a StatefulSet named 'my-database' to 3 replicas.**\n```bash\nkubectl scale statefulset my-database --replicas=3\n```"
      },
      {
        "id": 20,
        "text": "What is kubectl port-forward?",
        "explanation": "### Purpose: Forward one or more local ports to a Pod.\n\n**Explanation:** This command creates a secure, temporary connection from a port on your local machine directly to a port on a Pod (or Service) in the cluster. It's super useful for accessing internal services (like a database or an internal API) running in your cluster directly from your local development environment, without exposing them publicly.\n\n**Basic Example: Forward local port 8080 to port 80 of a Pod named 'my-frontend-pod'. Now you can access the Pod via `localhost:8080`.**\n```bash\nkubectl port-forward my-frontend-pod 8080:80\n```\n\n**Advanced Example: Forward local port 3306 to a MySQL Service named 'mysql-service' on its default port 3306, allowing you to connect locally.**\n```bash\nkubectl port-forward service/mysql-service 3306:3306\n```"
      },
      {
        "id": 21,
        "text": "What is kubectl edit?",
        "explanation": "### Purpose: Edit a resource's configuration live in the cluster.\n\n**Explanation:** This command allows you to directly open and modify the configuration of an existing Kubernetes resource (like a Pod, Service, or Deployment) using your default text editor. When you save and exit the editor, Kubernetes applies your changes to the live object. Use with caution, as direct edits can sometimes bypass validation layers that `kubectl apply` uses.\n\n**Basic Example: Open the configuration of the 'my-configmap' ConfigMap for editing.**\n```bash\nkubectl edit configmap my-configmap\n```\n\n**Advanced Example: Edit a Deployment named 'backend-service' in the 'staging' Namespace.**\n```bash\nkubectl edit deployment backend-service -n staging\n```"
      },
      {
        "id": 22,
        "text": "What is kubectl cp?",
        "explanation": "### Purpose: Copy files and directories to and from containers.\n\n**Explanation:** This command allows you to transfer files between your local machine and a container running inside a Pod. It's incredibly handy for debugging (e.g., pulling log files) or deploying small configuration updates without needing to rebuild a Docker image.\n\n**Basic Example: Copy a file named 'config.txt' from your current local directory into the '/app' directory inside a container of 'my-pod'.**\n```bash\nkubectl cp config.txt my-pod:/app/config.txt\n```\n\n**Advanced Example: Copy a directory named 'logs' from a specific container named 'processor' in 'my-pod' to your local current directory.**\n```bash\nkubectl cp my-pod:/var/log/app/logs ./logs -c processor\n```"
      },
      {
        "id": 23,
        "text": "What is kubectl top?",
        "explanation": "### Purpose: Display resource (CPU/memory) usage for nodes or pods.\n\n**Explanation:** This command gives you a quick snapshot of how much CPU and memory your nodes and Pods are currently consuming. It's a fundamental tool for monitoring your cluster's resource utilization and identifying potential performance bottlenecks or runaway processes. This command requires the Kubernetes Metrics Server to be running in your cluster.\n\n**Basic Example: Show CPU and memory usage for all Pods in the current Namespace.**\n```bash\nkubectl top pods\n```\n\n**Advanced Example: Show CPU and memory usage for all Nodes, ordered by CPU usage.**\n```bash\nkubectl top nodes --sort-by=cpu\n```"
      },
      {
        "id": 24,
        "text": "What is kubectl diff?",
        "explanation": "### Purpose: Show a diff between the live state and a proposed update.\n\n**Explanation:** Before you apply changes to your cluster (e.g., from a YAML file), `kubectl diff` allows you to see exactly what changes `kubectl apply` would make. It compares the configuration in your local file(s) with the current state of the resources in the cluster, showing you additions, deletions, and modifications. This prevents accidental changes and helps in validating your YAML files.\n\n**Basic Example: Show the differences between the live Deployment 'my-app' and the configuration in 'my-app.yaml' before applying.**\n```bash\nkubectl diff -f my-app.yaml\n```\n\n**Advanced Example: Show differences for all configurations in a directory, useful for large deployments.**\n```bash\nkubectl diff -f ./app-configs/\n```"
      },
      {
        "id": 25,
        "text": "What is kubectl label?",
        "explanation": "### Purpose: Update the labels on a resource.\n\n**Explanation:** Labels are key-value pairs that help organize and select Kubernetes resources. This command allows you to add, modify, or remove labels on existing objects without changing their underlying configuration. This is often used to group resources for management by other Kubernetes objects like Services or to mark specific objects for particular operations.\n\n**Basic Example: Add a label `environment=production` to a Pod named 'my-database-pod'.**\n```bash\nkubectl label pod my-database-pod environment=production\n```\n\n**Advanced Example: Remove the label `old-feature` from a Deployment.**\n```bash\nkubectl label deployment my-app old-feature-\n```"
      },
      {
        "id": 26,
        "text": "What is kubectl annotate?",
        "explanation": "### Purpose: Add or update annotations on a resource.\n\n**Explanation:** Annotations are also key-value pairs, similar to labels, but they are used for non-identifying metadata. This means they are not used for selecting or grouping resources (like labels are). Instead, they store arbitrary, non-critical information about a resource that might be useful for humans or automated tools, such as build information, contact details, or specific tool configurations.\n\n**Basic Example: Add an annotation with a build ID to a Deployment.**\n```bash\nkubectl annotate deployment my-app build-id=\"abc-123\"\n```\n\n**Advanced Example: Add a description annotation to a Service.**\n```bash\nkubectl annotate service my-service description=\"Main API gateway for customer facing services\"\n```"
      },
      {
        "id": 27,
        "text": "What is kubectl cordon?",
        "explanation": "### Purpose: Mark a node as unschedulable.\n\n**Explanation:** This command tells the Kubernetes scheduler *not* to place any new Pods on a specific node. Existing Pods on that node will continue to run, but no new ones will be added. This is useful when you need to perform maintenance on a node (like updating its operating system) and want to gracefully stop new workloads from being assigned to it.\n\n**Basic Example: Mark 'node1' as unschedulable for new Pods.**\n```bash\nkubectl cordon node1\n```"
      },
      {
        "id": 28,
        "text": "What is kubectl uncordon?",
        "explanation": "### Purpose: Mark a node as schedulable.\n\n**Explanation:** After you've finished maintenance on a node that was previously 'cordoned' (marked unschedulable), this command tells the Kubernetes scheduler that it can now start placing new Pods on that node again.\n\n**Basic Example: Allow 'node1' to receive new Pods again.**\n```bash\nkubectl uncordon node1\n```"
      },
      {
        "id": 29,
        "text": "What is kubectl drain?",
        "explanation": "### Purpose: Evict all Pods from a node safely.\n\n**Explanation:** This is a more comprehensive command for taking a node out of service. It first marks the node as unschedulable (like `cordon`), and then it *evicts* (gracefully shuts down and moves) all Pods from that node to other available nodes in the cluster. This is used when you need to take a node completely offline for maintenance and ensure all its workloads are safely migrated.\n\n**Basic Example: Drain all Pods from 'node1', respecting any Pod Disruption Budgets.**\n```bash\nkubectl drain node1\n```\n\n**Advanced Example: Drain 'node1' even if it has Pods using `emptyDir` volumes (data might be lost) and ignore DaemonSet Pods (which will be recreated on other nodes).**\n```bash\nkubectl drain node1 --delete-emptydir-data --ignore-daemonsets\n```"
      },
      {
        "id": 30,
        "text": "What is kubectl auth can-i?",
        "explanation": "### Purpose: Check API access permissions for a user or service account.\n\n**Explanation:** This is a powerful command for understanding Kubernetes' Role-Based Access Control (RBAC). It allows you to ask, 'Can I (or a specific user/Service Account) perform this action on this resource?' It's essential for troubleshooting permission issues and verifying security configurations.\n\n**Basic Example: Check if the current user can get (list) Pods in the current Namespace.**\n```bash\nkubectl auth can-i get pods\n```\n\n**Advanced Example: Check if the 'deployer-sa' Service Account in the 'ci-cd' Namespace can create Deployments in the 'production' Namespace.**\n```bash\nkubectl auth can-i create deployments --as=system:serviceaccount:ci-cd:deployer-sa -n production\n```"
      },
      {
        "id": 31,
        "text": "What is kubectl config use-context?",
        "explanation": "### Purpose: Switch between different Kubernetes clusters/contexts.\n\n**Explanation:** If you work with multiple Kubernetes clusters (e.g., development, staging, production) or different authentication methods, your `kubeconfig` file stores all these configurations. This command allows you to quickly switch which cluster `kubectl` is currently interacting with.\n\n**Basic Example: Switch to a context named 'my-dev-cluster'.**\n```bash\nkubectl config use-context my-dev-cluster\n```"
      },
      {
        "id": 32,
        "text": "What is kubectl completion?",
        "explanation": "### Purpose: Generate shell completion scripts for kubectl.\n\n**Explanation:** This command doesn't interact with the cluster directly. Instead, it generates a script that, when sourced in your shell (like Bash or Zsh), enables autocompletion for `kubectl` commands, flags, and resource names. This drastically speeds up your command-line work by allowing you to press Tab for suggestions.\n\n**Basic Example: Add kubectl autocompletion for Bash (add this line to your ~/.bashrc or ~/.bash_profile).**\n```bash\nsource <(kubectl completion bash)\n```"
      },
      {
        "id": 33,
        "text": "What is kubectl explain?",
        "explanation": "### Purpose: Get documentation for Kubernetes resources.\n\n**Explanation:** This is like having a built-in dictionary for Kubernetes object definitions. You can use it to understand the structure and purpose of fields within different Kubernetes resource types (like Pods, Deployments, Services). It's great for learning what options are available when writing your YAML files and understanding their purpose.\n\n**Basic Example: Get a high-level explanation of the Deployment resource.**\n```bash\nkubectl explain deployment\n```\n\n**Advanced Example: Get a detailed explanation of the 'spec.containers' field within a Pod definition.**\n```bash\nkubectl explain pod.spec.containers\n```"
      },
      {
        "id": 34,
        "text": "What is kubectl autoscale?",
        "explanation": "### Purpose: Automatically scale a Deployment, ReplicaSet, or StatefulSet.\n\n**Explanation:** This command creates a Horizontal Pod Autoscaler (HPA) resource, which automatically scales the number of Pods in your Deployment (or other workload) up or down based on observed CPU utilization or other metrics. It's crucial for efficiently handling varying workloads by adding or removing Pods as needed, optimizing resource usage and cost.\n\n**Basic Example: Autoscale the 'my-web-app' Deployment to maintain 80% CPU utilization, with a minimum of 2 and a maximum of 10 replicas.**\n```bash\nkubectl autoscale deployment my-web-app --cpu-percent=80 --min=2 --max=10\n```"
      },
      {
        "id": 35,
        "text": "What is kubectl rollout history?",
        "explanation": "### Purpose: View the revision history of a Deployment.\n\n**Explanation:** When you update a Deployment, Kubernetes creates a new 'revision' (a snapshot of its configuration). This command lets you see the history of these revisions, which is very useful for understanding what changes have been applied over time and for identifying specific versions for potential rollback.\n\n**Basic Example: Show the revision history for 'my-api-deployment'.**\n```bash\nkubectl rollout history deployment/my-api-deployment\n```"
      },
      {
        "id": 36,
        "text": "What is kubectl rollout undo?",
        "explanation": "### Purpose: Roll back a Deployment to a previous revision.\n\n**Explanation:** If a new deployment causes issues, this command allows you to quickly revert your application to a previous, stable version. It's a critical safety feature for managing application updates in production, letting you undo changes with minimal downtime.\n\n**Basic Example: Roll back 'my-api-deployment' to its immediately previous version.**\n```bash\nkubectl rollout undo deployment/my-api-deployment\n```\n\n**Advanced Example: Roll back 'my-api-deployment' to a specific revision number (e.g., revision 2).**\n```bash\nkubectl rollout undo deployment/my-api-deployment --to-revision=2\n```"
      },
      {
        "id": 37,
        "text": "What is kubectl taint?",
        "explanation": "### Purpose: Add or remove a taint from a node.\n\n**Explanation:** Taints are used to 'repel' Pods from a node. You can add a taint to a node to ensure that only Pods with a matching 'toleration' (a special permission) can be scheduled on that node. This is useful for dedicating nodes for specific types of workloads (e.g., sensitive data processing, GPU workloads) or for isolating problematic nodes.\n\n**Basic Example: Add a taint to 'node1' so only Pods tolerating 'special-use=true:NoSchedule' can be scheduled.**\n```bash\nkubectl taint node node1 special-use=true:NoSchedule\n```\n\n**Advanced Example: Remove the 'special-use' taint from 'node1'.**\n```bash\nkubectl taint node node1 special-use:NoSchedule-\n```"
      },
      {
        "id": 38,
        "text": "What is kubectl apply --prune?",
        "explanation": "### Purpose: Apply changes and prune (delete) resources not in the local configuration.\n\n**Explanation:** This is an advanced use of `kubectl apply` that helps maintain a strict desired state for your cluster. When used with `--prune`, it will not only create/update resources defined in your local configuration files but also *delete* any other Kubernetes resources (of the same type, in the same namespace, matching any provided labels) that are *not* defined in those files. It's useful for ensuring your live cluster's state precisely matches your configuration repository, removing anything extra.\n\n**Basic Example: Apply configurations from a folder, and delete any other resources (like Pods, Deployments, Services) in the 'my-app' Namespace that have the label `app=my-app` but are not defined in the specified files.**\n```bash\nkubectl apply -f ./my-app-configs/ --prune -l app=my-app -n my-app\n```"
      }
    ]
  }
}